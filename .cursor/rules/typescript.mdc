---
description: Enforces comprehensive TypeScript coding standards for maintainability, readability, and type safety
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: true
---
# TypeScript Comprehensive Standards Guide

## Description
This rule provides a single, unified reference for TypeScript development practices, combining coding style, architecture patterns, and type safety guidelines. It ensures consistent, high-quality, and maintainable TypeScript code across the entire codebase by enforcing strong typing, consistent naming conventions, proper error handling, and best implementation patterns.

## Trigger Conditions
- Creation of new TypeScript (.ts, .tsx) files
- Modification of existing TypeScript files
- Code review processes for TypeScript code
- Refactoring TypeScript components or services
- Implementing new TypeScript features
- Architecture discussions involving TypeScript

## Implementation Guidelines

### 1. Type Safety and Definitions (Highest Priority)
1. **Strong Typing**: Always use explicit types for variables, parameters, and return values
   - Avoid using implicit `any` type
   - Use interfaces for complex object shapes that will be implemented/extended
   - Use type aliases for unions, intersections, and simple object types
   - Define clear return types for all functions
   - Use generic types when appropriate for reusable components
   - Export types that are used across multiple files

2. **Avoiding `any`**: Never use the `any` type unless absolutely necessary
   - Use `unknown` instead of `any` when type is uncertain
   - Create proper interfaces/types instead of resorting to `any`
   - Use type guards for narrowing types
   - Document thoroughly if `any` must be used (with justification)
   - Utilize TypeScript utility types (`Partial<T>`, `Readonly<T>`, `Record<K,T>`, etc.)

3. **Type Declarations and Organization**:
   - Keep interface definitions focused and cohesive [types.ts](mdc:docs/api/services/types.ts)
   - Group related types together in dedicated type files 
   - Use descriptive names that reflect the purpose
   - Add JSDoc comments for complex types 
   - Consider breaking large interfaces into smaller, composable ones

### 2. Naming Conventions (High Priority)
1. **Consistent Type and Class Naming**:
   - Use PascalCase for classes, interfaces, types, and enums
   - Prefix interfaces with 'I' only if they're used for implementation inheritance
   - Use nouns or noun phrases for entity types
   - Be descriptive and specific

2. **Consistent Function and Variable Naming**:
   - Use camelCase for functions, methods, properties, and variables
   - Use descriptive verb phrases for functions that indicate purpose
   - Prefix boolean getters with 'is', 'has', 'can', etc. (e.g., `isValid`)
   - Use UPPER_SNAKE_CASE for constants
   - Use descriptive nouns or noun phrases for variables

3. **File and Folder Structure**:
   - Use kebab-case for file names (e.g., `user-service.ts`)
   - Group related functionality into appropriate directories
   - Follow a consistent pattern for similar files
   - Keep filenames consistent with their primary export
   - Maximum file length: 300 lines (refactor if longer)

### 3. Error Handling and Safety (High Priority)
1. **Null and Undefined Handling**:
   - Use explicit null/undefined checking
   - Prefer optional chaining (?.) and nullish coalescing (??)
   - Use non-null assertion operator (!) only when absolutely certain
   - Avoid returning undefined/null from functions when possible
   - Handle potential null values early in functions

2. **Exception Management**:
   - Implement proper error handling with try/catch blocks
   - Create custom error types for different error categories
   - Provide meaningful error messages
   - Log errors appropriately
   - Avoid swallowing errors without handling them

3. **Input Validation**:
   - Validate function inputs at the start of functions
   - Use guard clauses for early returns
   - Consider using validation libraries for complex inputs
   - Document validation requirements in function JSDoc
   - Throw descriptive errors for invalid inputs

### 4. Code Structure and Organization (Medium Priority)
1. **Function Design**:
   - Keep functions small and focused on a single task
   - Maximum function length: 30 lines (refactor if longer)
   - Use arrow functions for anonymous functions and callbacks
   - Prefer function parameters with default values over conditionals
   - Prefer named parameters for complex function signatures
   - Document complex functions with JSDoc

2. **Class Design**:
   - Use access modifiers for all class members (`public`, `private`, `protected`)
   - Initialize class properties either in declaration or constructor
   - Use `readonly` for properties that won't change after initialization
   - Use getters/setters for properties that need controlled access
   - Follow single responsibility principle for classes
   - Consider composition over inheritance

3. **Architecture Patterns**:
   - Follow defined architecture patterns consistently
   - Organize code according to logical separation of concerns
   - Use dependency injection for services
   - Implement singleton pattern appropriately
   - Use factory patterns for complex object creation
   - Document architectural decisions

### 5. Testing Standards (High Priority)
1. **Test Organization**:
   - Write tests for all public APIs
   - Name test files consistently (e.g., `[name].test.ts` or `[name].spec.ts`)
   - Structure tests with arrange-act-assert pattern
   - Group related tests in describes
   - Use descriptive test names that indicate expected behavior

2. **Mocking and Isolation**:
   - Mock dependencies appropriately for unit tests
   - Use test doubles (spies, stubs, mocks) appropriately
   - Isolate the unit under test
   - Mock external services and APIs
   - Use consistent mocking patterns

3. **Coverage and Quality**:
   - Aim for high test coverage (minimum 80%)
   - Test edge cases and error conditions
   - Include both positive and negative test cases
   - Ensure tests are deterministic and repeatable
   - Avoid test interdependencies

### 6. Code Formatting and Style (Medium Priority)
1. **Formatting Rules**:
   - Use 2 spaces for indentation
   - Use single quotes for strings
   - Always end statements with semicolons
   - Maximum line length: 100 characters
   - Use trailing commas in multi-line object and array literals
   - Place opening braces on the same line as their statement
   - Add space before opening parenthesis in control statements
   - No space between function name and parentheses for function calls

2. **Comments and Documentation**:
   - Use JSDoc comments for public APIs and complex functions
   - Keep comments focused on why, not what
   - Update comments when code changes
   - Document complex algorithms and business logic
   - Avoid commented-out code

3. **Import and Export Rules**:
   - Group imports by source (external, then internal)
   - Sort imports alphabetically within each group
   - Use named exports rather than default exports
   - Use explicit import statements rather than wildcard imports
   - Avoid circular dependencies

### 7. Documentation Standards (High Priority)
1. **File Documentation**:
   - Add a file header JSDoc comment for every TypeScript file
   - Document the file's purpose and responsibility
   - List any major dependencies or related files
   - Include any important notes about usage or limitations
   - Example:
   ```typescript
   /**
    * @file PlayerController.ts
    * @description Manages player input and movement in the game world
    * @dependencies
    * - InputManager - Handles raw input processing
    * - PhysicsSystem - Manages collision and movement
    * @limitations
    * - Currently only supports keyboard/mouse input
    * - Maximum movement speed is capped at 1000 pixels/sec
    */
   ```

2. **Class and Interface Documentation**:
   - Document all classes and interfaces with JSDoc comments
   - Explain the purpose and behavior of the class/interface
   - Document any inheritance or implementation relationships
   - List important methods and properties
   - Include usage examples for complex classes
   - Example:
   ```typescript
   /**
    * Manages game entity state transitions and validates state changes
    * @implements {IStateMachine<EntityState>}
    * @example
    * const stateMachine = new EntityStateMachine(entity);
    * stateMachine.addTransition('idle', 'walking', () => true);
    * stateMachine.transition('walking');
    */
   export class EntityStateMachine implements IStateMachine<EntityState> {
   ```

3. **Method and Function Documentation**:
   - Document all public methods and functions with JSDoc
   - Clearly describe the function's purpose and behavior
   - Document all parameters and return values
   - Include type information even when TypeScript provides it
   - Document thrown exceptions and side effects
   - Provide usage examples for complex functions
   - Example:
   ```typescript
   /**
    * Transitions an entity to a new state if the transition is valid
    * @param {EntityState} newState - The state to transition to
    * @param {TransitionOptions} [options] - Optional transition configuration
    * @returns {boolean} True if transition was successful, false otherwise
    * @throws {InvalidStateError} If the new state is not registered
    * @example
    * if (stateMachine.transition('attacking', { duration: 500 })) {
    *   console.log('Entity is now attacking');
    * }
    */
   public transition(newState: EntityState, options?: TransitionOptions): boolean {
   ```

4. **Property Documentation**:
   - Document complex properties with JSDoc comments
   - Explain the purpose and usage of the property
   - Document any validation or constraints
   - Include examples if usage is not obvious
   - Example:
   ```typescript
   /**
    * Current velocity vector of the entity
    * @type {Vector2}
    * @remarks
    * - X component represents horizontal velocity (-1 to 1)
    * - Y component represents vertical velocity (-1 to 1)
    * - Magnitude is automatically clamped to 1
    */
   private velocity: Vector2;
   ```

5. **Type and Enum Documentation**:
   - Document all type aliases and enums
   - Explain the purpose and valid values
   - Include examples of proper usage
   - Document any validation or constraints
   - Example:
   ```typescript
   /**
    * Represents possible states for game entities
    * @enum {string}
    * @readonly
    */
   export enum EntityState {
     /** Entity is not performing any action */
     IDLE = 'idle',
     /** Entity is moving in some direction */
     WALKING = 'walking',
     /** Entity is performing an attack action */
     ATTACKING = 'attacking'
   }
   ```

6. **Code Examples and Usage Documentation**:
   - Include practical examples in JSDoc comments
   - Show common use cases and patterns
   - Demonstrate proper error handling
   - Include examples of integration with other components
   - Example:
   ```typescript
   /**
    * Manages game audio with support for multiple channels and effects
    * @example
    * // Basic usage
    * const audio = new AudioManager();
    * await audio.init();
    * audio.playSound('explosion', { volume: 0.8 });
    * 
    * // With effects
    * audio.addEffect('explosion', {
    *   reverb: true,
    *   delay: 0.2
    * });
    */
   export class AudioManager {
   ```

7. **Limitations and Special Considerations**:
   - Document known limitations and edge cases
   - Explain performance implications
   - Note browser compatibility issues
   - Document memory usage considerations
   - List any required permissions or setup
   - Example:
   ```typescript
   /**
    * Handles WebGL shader effects for game rendering
    * @limitations
    * - Requires WebGL 2.0 support
    * - Maximum of 16 simultaneous effects
    * - High memory usage with multiple active effects
    * @performance
    * - Consider using pooling for particle effects
    * - Disable effects on low-end devices
    */
   export class EffectManager {
   ```

// ... existing code ...

## Examples

### Type Safety Examples
```typescript
// Good example - strong typing
interface UserProfile {
  id: string;
  displayName: string;
  email: string;
  preferences: UserPreferences;
  lastLogin: Date;
}

function getUserById(userId: string): Promise<UserProfile> {
  // Implementation
  return fetchUser(userId);
}

// Bad example - weak typing
function getUserById(userId) {
  // Implementation using any implicitly
  return fetchUser(userId);
}
```

### Error Handling Examples
```typescript
// Good example - proper error handling
async function loadUserData(userId: string): Promise<UserData> {
  if (!userId) {
    throw new Error('User ID is required');
  }
  
  try {
    const response = await api.fetchUser(userId);
    return response.data;
  } catch (error) {
    logger.error(`Failed to load user data: ${error.message}`);
    throw new UserDataError('Could not load user data', { cause: error });
  }
}

// Bad example - poor error handling
async function loadUserData(userId) {
  const response = await api.fetchUser(userId);
  return response.data;
}
```

### Class Structure Examples
```typescript
// Good example - well-structured class
export class PlayerController implements IController {
  private readonly player: Player;
  private readonly inputManager: InputManager;
  
  constructor(player: Player, inputManager: InputManager) {
    this.player = player;
    this.inputManager = inputManager;
  }
  
  public update(deltaTime: number): void {
    const input = this.inputManager.getCurrentInput();
    this.handleMovement(input.direction, deltaTime);
    this.handleActions(input.actions);
  }
  
  private handleMovement(direction: Vector2, deltaTime: number): void {
    if (direction.magnitude() > 0) {
      this.player.move(direction.normalized().scale(this.player.speed * deltaTime));
    }
  }
  
  private handleActions(actions: PlayerAction[]): void {
    actions.forEach(action => this.player.performAction(action));
  }
}

// Bad example - poorly structured class
class PlayerController {
  player: any;
  input: any;
  
  update() {
    // Directly accessing properties without type safety
    let x = this.input.x;
    let y = this.input.y;
    this.player.x += x;
    this.player.y += y;
    
    // Mixing concerns in a single method
    if (this.input.jump) {
      this.player.jump();
    }
    // More code...
  }
}
```

### Testing Examples
```typescript
// Good example - well-structured test
describe('PlayerController', () => {
  let controller: PlayerController;
  let mockPlayer: jest.Mocked<Player>;
  let mockInputManager: jest.Mocked<InputManager>;
  
  beforeEach(() => {
    mockPlayer = createMockPlayer();
    mockInputManager = createMockInputManager();
    controller = new PlayerController(mockPlayer, mockInputManager);
  });
  
  describe('update', () => {
    it('should move the player when input direction is provided', () => {
      // Arrange
      const direction = new Vector2(1, 0);
      const deltaTime = 0.016;
      mockInputManager.getCurrentInput.mockReturnValue({
        direction,
        actions: []
      });
      
      // Act
      controller.update(deltaTime);
      
      // Assert
      expect(mockPlayer.move).toHaveBeenCalledWith(
        expect.objectContaining({ 
          x: expect.any(Number), 
          y: expect.any(Number) 
        })
      );
    });
  });
});

// Bad example - poor test structure
test('player controller works', () => {
  const controller = new PlayerController(new Player(), new InputManager());
  controller.update();
  // No clear assertions or structure
  expect(controller).toBeDefined();
});
```

## Best Practices
- Always define explicit return types for functions
- Keep classes and functions focused on a single responsibility
- Document complex logic with clear comments
- Write self-documenting code through descriptive naming
- Test thoroughly, including edge cases
- Maintain consistent patterns across the codebase
- Use TypeScript's utility types when appropriate
- Keep code DRY (Don't Repeat Yourself)
- Refactor large files into smaller, focused modules
- Follow the established architecture patterns
- Use asynchronous patterns consistently
- Keep dependency trees shallow

## Integration
- Works with ESLint configuration for TypeScript
- Complements project architecture guidelines
- Supports testing framework configuration
- Aligns with TypeScript compiler options
- Integrates with build pipeline and CI/CD processes
- Provides standards for code review processes
- Works alongside documentation standards

## Version Control
- Current version: v1.0.0
- Last updated: 2023-11-10
- Change history: Initial creation combining typescript-standards.mdc and ts-style.mdc

## Success Metrics
- Reduction in TypeScript-related bugs and errors
- Decrease in usage of 'any' type across codebase
- Improved code review efficiency
- Higher test coverage percentage
- Consistent naming pattern adherence
- Better code maintainability
- Faster onboarding for new developers
- Reduction in technical debt
- Improved static analysis results

### Comments and Documentation
- Follow Documentation Standards section for JSDoc comments (see Section 7)
- Keep inline comments focused on explaining complex logic or non-obvious decisions
- Update documentation when code changes
- Document complex algorithms with clear explanations and references
- Avoid commented-out code
- Use TODO comments with tracking tickets for planned changes
- Add references to related documentation when appropriate
- Follow JSDoc standards for all documentation
- Include examples for complex or non-obvious code
- Document assumptions and preconditions 