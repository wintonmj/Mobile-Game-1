---
description: Enforces comprehensive TypeScript coding standards for maintainability, readability, and type safety
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: true
Rule Type: Auto
---
# TypeScript Comprehensive Standards Guide

## Description
This rule provides a single, unified reference for TypeScript development practices, combining coding style, architecture patterns, and type safety guidelines. It ensures consistent, high-quality, and maintainable TypeScript code across the entire codebase by enforcing strong typing, consistent naming conventions, proper error handling, and best implementation patterns.

## Trigger Conditions
- Creation of new TypeScript (.ts, .tsx) files
- Modification of existing TypeScript files
- Code review processes for TypeScript code
- Refactoring TypeScript components or services
- Implementing new TypeScript features
- Architecture discussions involving TypeScript

## Implementation Guidelines

### 1. Type Safety and Definitions (Highest Priority)
1. **Strong Typing**: Always use explicit types for variables, parameters, and return values
   - Avoid using implicit `any` type
   - Use interfaces for complex object shapes that will be implemented/extended
   - Use type aliases for unions, intersections, and simple object types
   - Define clear return types for all functions
   - Use generic types when appropriate for reusable components
   - Export types that are used across multiple files

2. **Avoiding `any`**: Never use the `any` type unless absolutely necessary
   - Use `unknown` instead of `any` when type is uncertain
   - Create proper interfaces/types instead of resorting to `any`
   - Use type guards for narrowing types
   - Document thoroughly if `any` must be used (with justification)
   - Utilize TypeScript utility types (`Partial<T>`, `Readonly<T>`, `Record<K,T>`, etc.)

3. **Type Declarations and Organization**:
   - Keep interface definitions focused and cohesive
   - Group related types together in dedicated type files
   - Use descriptive names that reflect the purpose
   - Add JSDoc comments for complex types
   - Consider breaking large interfaces into smaller, composable ones

### 2. Naming Conventions (High Priority)
1. **Consistent Type and Class Naming**:
   - Use PascalCase for classes, interfaces, types, and enums
   - Prefix interfaces with 'I' only if they're used for implementation inheritance
   - Use nouns or noun phrases for entity types
   - Be descriptive and specific

2. **Consistent Function and Variable Naming**:
   - Use camelCase for functions, methods, properties, and variables
   - Use descriptive verb phrases for functions that indicate purpose
   - Prefix boolean getters with 'is', 'has', 'can', etc. (e.g., `isValid`)
   - Use UPPER_SNAKE_CASE for constants
   - Use descriptive nouns or noun phrases for variables

3. **File and Folder Structure**:
   - Use kebab-case for file names (e.g., `user-service.ts`)
   - Group related functionality into appropriate directories
   - Follow a consistent pattern for similar files
   - Keep filenames consistent with their primary export
   - Maximum file length: 300 lines (refactor if longer)

### 3. Error Handling and Safety (High Priority)
1. **Null and Undefined Handling**:
   - Use explicit null/undefined checking
   - Prefer optional chaining (?.) and nullish coalescing (??)
   - Use non-null assertion operator (!) only when absolutely certain
   - Avoid returning undefined/null from functions when possible
   - Handle potential null values early in functions

2. **Exception Management**:
   - Implement proper error handling with try/catch blocks
   - Create custom error types for different error categories
   - Provide meaningful error messages
   - Log errors appropriately
   - Avoid swallowing errors without handling them

3. **Input Validation**:
   - Validate function inputs at the start of functions
   - Use guard clauses for early returns
   - Consider using validation libraries for complex inputs
   - Document validation requirements in function JSDoc
   - Throw descriptive errors for invalid inputs

### 4. Code Structure and Organization (Medium Priority)
1. **Function Design**:
   - Keep functions small and focused on a single task
   - Maximum function length: 30 lines (refactor if longer)
   - Use arrow functions for anonymous functions and callbacks
   - Prefer function parameters with default values over conditionals
   - Prefer named parameters for complex function signatures
   - Document complex functions with JSDoc

2. **Class Design**:
   - Use access modifiers for all class members (`public`, `private`, `protected`)
   - Initialize class properties either in declaration or constructor
   - Use `readonly` for properties that won't change after initialization
   - Use getters/setters for properties that need controlled access
   - Follow single responsibility principle for classes
   - Consider composition over inheritance

3. **Architecture Patterns**:
   - Follow defined architecture patterns consistently
   - Organize code according to logical separation of concerns
   - Use dependency injection for services
   - Implement singleton pattern appropriately
   - Use factory patterns for complex object creation
   - Document architectural decisions

### 5. Testing Standards (High Priority)
1. **Test Organization**:
   - Write tests for all public APIs
   - Name test files consistently (e.g., `[name].test.ts` or `[name].spec.ts`)
   - Structure tests with arrange-act-assert pattern
   - Group related tests in describes
   - Use descriptive test names that indicate expected behavior

2. **Mocking and Isolation**:
   - Mock dependencies appropriately for unit tests
   - Use test doubles (spies, stubs, mocks) appropriately
   - Isolate the unit under test
   - Mock external services and APIs
   - Use consistent mocking patterns

3. **Coverage and Quality**:
   - Aim for high test coverage (minimum 80%)
   - Test edge cases and error conditions
   - Include both positive and negative test cases
   - Ensure tests are deterministic and repeatable
   - Avoid test interdependencies

### 6. Code Formatting and Style (Medium Priority)
1. **Formatting Rules**:
   - Use 2 spaces for indentation
   - Use single quotes for strings
   - Always end statements with semicolons
   - Maximum line length: 100 characters
   - Use trailing commas in multi-line object and array literals
   - Place opening braces on the same line as their statement
   - Add space before opening parenthesis in control statements
   - No space between function name and parentheses for function calls

2. **Comments and Documentation**:
   - Use JSDoc comments for public APIs and complex functions
   - Keep comments focused on why, not what
   - Update comments when code changes
   - Document complex algorithms and business logic
   - Avoid commented-out code

3. **Import and Export Rules**:
   - Group imports by source (external, then internal)
   - Sort imports alphabetically within each group
   - Use named exports rather than default exports
   - Use explicit import statements rather than wildcard imports
   - Avoid circular dependencies

## Examples

### Type Safety Examples
```typescript
// Good example - strong typing
interface UserProfile {
  id: string;
  displayName: string;
  email: string;
  preferences: UserPreferences;
  lastLogin: Date;
}

function getUserById(userId: string): Promise<UserProfile> {
  // Implementation
  return fetchUser(userId);
}

// Bad example - weak typing
function getUserById(userId) {
  // Implementation using any implicitly
  return fetchUser(userId);
}
```

### Error Handling Examples
```typescript
// Good example - proper error handling
async function loadUserData(userId: string): Promise<UserData> {
  if (!userId) {
    throw new Error('User ID is required');
  }
  
  try {
    const response = await api.fetchUser(userId);
    return response.data;
  } catch (error) {
    logger.error(`Failed to load user data: ${error.message}`);
    throw new UserDataError('Could not load user data', { cause: error });
  }
}

// Bad example - poor error handling
async function loadUserData(userId) {
  const response = await api.fetchUser(userId);
  return response.data;
}
```

### Class Structure Examples
```typescript
// Good example - well-structured class
export class PlayerController implements IController {
  private readonly player: Player;
  private readonly inputManager: InputManager;
  
  constructor(player: Player, inputManager: InputManager) {
    this.player = player;
    this.inputManager = inputManager;
  }
  
  public update(deltaTime: number): void {
    const input = this.inputManager.getCurrentInput();
    this.handleMovement(input.direction, deltaTime);
    this.handleActions(input.actions);
  }
  
  private handleMovement(direction: Vector2, deltaTime: number): void {
    if (direction.magnitude() > 0) {
      this.player.move(direction.normalized().scale(this.player.speed * deltaTime));
    }
  }
  
  private handleActions(actions: PlayerAction[]): void {
    actions.forEach(action => this.player.performAction(action));
  }
}

// Bad example - poorly structured class
class PlayerController {
  player: any;
  input: any;
  
  update() {
    // Directly accessing properties without type safety
    let x = this.input.x;
    let y = this.input.y;
    this.player.x += x;
    this.player.y += y;
    
    // Mixing concerns in a single method
    if (this.input.jump) {
      this.player.jump();
    }
    // More code...
  }
}
```

### Testing Examples
```typescript
// Good example - well-structured test
describe('PlayerController', () => {
  let controller: PlayerController;
  let mockPlayer: jest.Mocked<Player>;
  let mockInputManager: jest.Mocked<InputManager>;
  
  beforeEach(() => {
    mockPlayer = createMockPlayer();
    mockInputManager = createMockInputManager();
    controller = new PlayerController(mockPlayer, mockInputManager);
  });
  
  describe('update', () => {
    it('should move the player when input direction is provided', () => {
      // Arrange
      const direction = new Vector2(1, 0);
      const deltaTime = 0.016;
      mockInputManager.getCurrentInput.mockReturnValue({
        direction,
        actions: []
      });
      
      // Act
      controller.update(deltaTime);
      
      // Assert
      expect(mockPlayer.move).toHaveBeenCalledWith(
        expect.objectContaining({ 
          x: expect.any(Number), 
          y: expect.any(Number) 
        })
      );
    });
  });
});

// Bad example - poor test structure
test('player controller works', () => {
  const controller = new PlayerController(new Player(), new InputManager());
  controller.update();
  // No clear assertions or structure
  expect(controller).toBeDefined();
});
```

## Best Practices
- Always define explicit return types for functions
- Keep classes and functions focused on a single responsibility
- Document complex logic with clear comments
- Write self-documenting code through descriptive naming
- Test thoroughly, including edge cases
- Maintain consistent patterns across the codebase
- Use TypeScript's utility types when appropriate
- Keep code DRY (Don't Repeat Yourself)
- Refactor large files into smaller, focused modules
- Follow the established architecture patterns
- Use asynchronous patterns consistently
- Keep dependency trees shallow

## Integration
- Works with ESLint configuration for TypeScript
- Complements project architecture guidelines
- Supports testing framework configuration
- Aligns with TypeScript compiler options
- Integrates with build pipeline and CI/CD processes
- Provides standards for code review processes
- Works alongside documentation standards

## Version Control
- Current version: v1.0.0
- Last updated: 2023-11-10
- Change history: Initial creation combining typescript-standards.mdc and ts-style.mdc

## Success Metrics
- Reduction in TypeScript-related bugs and errors
- Decrease in usage of 'any' type across codebase
- Improved code review efficiency
- Higher test coverage percentage
- Consistent naming pattern adherence
- Better code maintainability
- Faster onboarding for new developers
- Reduction in technical debt
- Improved static analysis results 