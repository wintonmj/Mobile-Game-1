---
description: 
globs: **/src/__tests__/**/*.ts
alwaysApply: false
---
 # Jest Mocking Best Practices

## Singleton Pattern for Controller Mocks

Always use a singleton pattern when mocking controllers or services that may be instantiated multiple times but should share the same mock functions:

```typescript
// DON'T:
export const Controller = jest.fn().mockImplementation(() => {
  return {
    method1: jest.fn(),
    method2: jest.fn()
  };
});

// DO:
const mockFunctions = {
  method1: jest.fn(),
  method2: jest.fn()
};

const mockInstance = {
  method1: mockFunctions.method1,
  method2: mockFunctions.method2
};

export const Controller = jest.fn().mockImplementation(() => {
  return mockInstance;
});

export default { mockFunctions };
```

Use @ts-nocheck - This avoids TypeScript errors when directly accessing private properties in tests.
Don't rely on the initialization process - The main issue with InputController.test.ts was it relied on the init() method correctly setting up the internal state. Instead, we should:
Directly set properties needed for testing
Create test-specific implementations of methods
Focus on testing the public interface, not implementation details
Create a simple test-specific class - Instead of trying to mock the complex InputController with its dependencies on Phaser, we created a test-specific version that mimics the interface but is fully under our control.
Avoid deep mock structures - The original approach required complex mock structures for Phaser, scene, cursors, keys, etc. This creates many points of failure.
Mock at the right level - Instead of mocking low-level Phaser objects, we mocked at a higher level by creating a "TestableInputController" with the same interface.
Test functional behavior, not implementation - We test what the methods do, not how they do it.
Independent tests - Each test sets up its own state, avoiding dependencies between tests.

## Jest Module Mapping

Ensure your moduleNameMapper in jest.config.js covers all possible import paths:

```javascript
moduleNameMapper: {
  '^../../controllers/MyController$': '<rootDir>/src/__tests__/mocks/myController.ts',
  '^../controllers/MyController$': '<rootDir>/src/__tests__/mocks/myController.ts',
  '^./MyController$': '<rootDir>/src/__tests__/mocks/myController.ts',
}
```

## Testing Mock Calls

When testing that mock functions were called:

1. Clear mock calls before key operations:
```typescript
mockFunctions.method.mockClear();
controller.performAction();
expect(mockFunctions.method).toHaveBeenCalled();
```

2. Be specific when testing conditional actions:
```typescript
mockFunctions.isActionPressed.mockImplementation((action) => {
  // Be explicit about which action returns true
  return action === Actions.SPECIFIC_ACTION;
});
```

## Common Pitfalls

- **Class Instantiation**: If a class creates new instances of other classes in its constructor, make sure those dependencies are mocked BEFORE the class is instantiated.

- **Mock References**: Always access mock functions through your exported mockFunctions object, not through the class instance or prototype.

- **Test Isolation**: Use `jest.clearAllMocks()` in beforeEach to prevent test interference.

- **Conditional Logic**: When mocking methods that participate in conditional logic (like isActionPressed), make sure your mock implementation matches the expected conditions.

1. Direct property injection: Instead of trying to mock dependencies through complex import mocking, we directly set properties on the GameScene instance, which made the tests more robust.
2. Isolated tests: Each test only tests what it needs to, with proper setup and teardown.
3. Type safety: We used TypeScript's @ts-nocheck to avoid complex typing issues with our mocks, since we're using manual mocking patterns.
4. Simple mock objects: We created straightforward mock objects that implement just the interfaces needed for each test.
5. Global constructor mocking: We carefully managed global constructor overrides, ensuring they're cleaned up after each test.
The only line not covered is line 50 in GameScene.ts, which appears to be an error handler in the preload method. If we wanted even higher coverage, we could add a test that specifically triggers that error condition.
This testing approach can be extended for other components in your codebase, providing a reliable framework for testing classes that interact with Phaser and other external dependencies. The tests we've written are maintainable and focused on testing behavior rather than implementation details.