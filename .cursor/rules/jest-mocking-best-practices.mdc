---
description: 
globs: **/src/__tests__/**/*.ts
alwaysApply: false
---
---
description: Best practices for Jest mocking and testing
globs: ['**/src/__tests__/**/*']
alwaysApply: false
---
# Jest Mocking Best Practices

## Table of Contents
1. [Core Mocking Patterns](#core-mocking-patterns)
2. [Module Configuration](#module-configuration)
3. [Testing Patterns](#testing-patterns)
4. [Error Handling](#error-handling)
5. [Common Pitfalls](#common-pitfalls)

## Core Mocking Patterns

### Singleton Pattern for Controllers

Always use a singleton pattern when mocking controllers or services that may be instantiated multiple times but should share the same mock functions:

```typescript
// DON'T:
export const Controller = jest.fn().mockImplementation(() => {
  return {
    method1: jest.fn(),
    method2: jest.fn()
  };
});

// DO:
const mockFunctions = {
  method1: jest.fn(),
  method2: jest.fn()
};

const mockInstance = {
  method1: mockFunctions.method1,
  method2: mockFunctions.method2
};

export const Controller = jest.fn().mockImplementation(() => {
  return mockInstance;
});

export default { mockFunctions };
```

### Mock Class Implementation

When mocking classes, follow this pattern for consistency:

```typescript
class MockClass {
  private static instance: MockClass;
  
  private constructor() {
    // Initialize mock functions with proper typing
    this.method1 = jest.fn();
    this.method2 = jest.fn();
    
    // Set default implementations
    this.method1.mockImplementation(() => {
      // Default implementation
    });
  }

  static getInstance(): MockClass {
    if (!MockClass.instance) {
      MockClass.instance = new MockClass();
    }
    return MockClass.instance;
  }

  // Mock functions with proper typing
  method1: jest.Mock;
  method2: jest.Mock;
}
```

## Module Configuration

### Jest Module Mapping

Ensure your moduleNameMapper in jest.config.js covers all possible import paths:

```javascript
moduleNameMapper: {
  '^../../controllers/MyController$': '<rootDir>/src/__tests__/mocks/myController.ts',
  '^../controllers/MyController$': '<rootDir>/src/__tests__/mocks/myController.ts',
  '^./MyController$': '<rootDir>/src/__tests__/mocks/myController.ts',
}
```

### Test Setup

Configure global Jest behavior in setup.ts:

```typescript
beforeEach(() => {
  jest.clearAllMocks();
  // Additional setup as needed
});
```

## Testing Patterns

### Testing Mock Calls

When testing that mock functions were called:

1. Clear mock calls before key operations:
```typescript
mockFunctions.method.mockClear();
controller.performAction();
expect(mockFunctions.method).toHaveBeenCalled();
```

2. Be specific when testing conditional actions:
```typescript
mockFunctions.isActionPressed.mockImplementation((action) => {
  return action === Actions.SPECIFIC_ACTION;
});
```

### Test Structure

Follow the Arrange-Act-Assert pattern:

```typescript
test('should perform action', () => {
  // Arrange
  mockFunctions.method.mockReturnValue(expectedValue);
  
  // Act
  const result = controller.performAction();
  
  // Assert
  expect(result).toBe(expectedValue);
  expect(mockFunctions.method).toHaveBeenCalled();
});
```

## Error Handling

### Error Mocking

When mocking errors, ensure consistent error structure:

```typescript
// DON'T: Use inconsistent error structures
const error = new Error('Something went wrong');
error.code = 'SOME_ERROR'; // Missing proper type casting

// DO: Match the exact error type and structure
const error = new Error('File not found') as NodeJS.ErrnoException;
error.code = 'ENOENT';
throw error;
```

### Error Testing

Test error scenarios explicitly:

```typescript
test('handles file not found', async () => {
  // Arrange
  const error = new Error('File not found') as NodeJS.ErrnoException;
  error.code = 'ENOENT';
  mockFunctions.readFile.mockRejectedValueOnce(error);
  
  // Act & Assert
  await expect(service.loadFile()).rejects.toThrow('File not found');
});
```

## Common Pitfalls

### 1. Class Instantiation
- Mock dependencies BEFORE instantiating classes
- Use proper typing for mock functions
- Avoid complex mock structures

### 2. Mock References
- Access mock functions through exported mockFunctions object
- Don't rely on class instance or prototype
- Keep mock implementations simple

### 3. Test Isolation
- Use `jest.clearAllMocks()` in beforeEach
- Reset environment variables after tests
- Clean up global mocks

### 4. Conditional Logic
- Make mock implementations match expected conditions
- Test both success and failure paths
- Verify error handling

### 5. Type Safety
- Use proper TypeScript types for mocks
- Avoid using `any` type
- Use type assertions when necessary

## Best Practices Summary

1. **Organization**
   - Keep mock files in dedicated `__tests__/mocks` directory
   - Use consistent naming conventions
   - Group related mocks together

2. **Implementation**
   - Use singleton pattern for shared mocks
   - Implement proper typing
   - Set default mock implementations

3. **Testing**
   - Follow Arrange-Act-Assert pattern
   - Test both success and error cases
   - Verify mock calls explicitly

4. **Maintenance**
   - Keep mocks simple and focused
   - Document complex mock behavior
   - Update mocks when interfaces change 